<!DOCTYPE html>

<html>
    <head>
        <style>
            html { background-color: #121314; }
        </style>
        <meta name="robots" content="noindex,nofollow">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700" rel="stylesheet">
        <link rel="preconnect" href="https://rsms.me/">
        <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
        <link rel="stylesheet" href="styles.css">
        <title>
            Jesse Wu
        </title>
    </head>
  
    <body>
        <div id="wrapper">
            <div id="hero">
                <!--<div class="description">Hi, I'm</div>-->
                <img src="img/profile-pic.png" class="profile-pic">
                <div class="title">
                    <!--<div class="circle"></div>-->
                    Jesse Wu
                    <p class="subtitle">Product Designer</p>
                </div>
                <div class="divider short"></div>
                <div class="description">
                    <p id="paragraph-1">I'm a designer who thrives in technical problem spaces. I have 6 years of experience in B2B enterprise platform security and user management.</p>
                    <p id="paragraph-2">With a background in design and engineering, I've tackled complex areas to deliver robust, end-to-end solutions that address customer needs by following a design process rooted in research, ideation, and collaboration.</p>
                    <p id="paragraph-3">If you're looking for a passionate designer who works hard and smart, strives to constantly learn and improve, and synergizes well with others on a team, contact me at <a href="mailto:jwu9993@gmail.com"> jwu9993@gmail.com</a>.</p>
                    <p>
                </div>
        </div>

        <script>
            window.addEventListener('load', function() {
                // 1. Define the callback function
                const handleIntersection = (entries, observer) => {
                  entries.forEach(entry => {
                    // Check if the target element is intersecting with the root (viewport by default)
                    if (entry.isIntersecting) {
                        console.log('Target element is now visible! Its ID + entry.target.id');
                        document.querySelector('.profile-pic').classList.add('fadein-1');
                        document.querySelector('.title').classList.add('fadein-2');
                        document.querySelector('.divider.short').classList.add('fadein-3');
                        document.querySelector('#paragraph-1').classList.add('fadein-3');
                        document.querySelector('#paragraph-2').classList.add('fadein-4');
                        document.querySelector('#paragraph-3').classList.add('fadein-5');
                        // Optional: Stop observing the element after the first intersection
                        observer.unobserve(entry.target);
                    }
                  });
                };

                // 2. Define the options (optional, uses defaults if omitted)
                const options = {
                  root: null, // Use the document's viewport as the root
                  rootMargin: '0px', // No margin around the root
                  threshold: 1.0 // Trigger callback when 100% of the target is visible
                };

                // 3. Create the observer instance
                const observer = new IntersectionObserver(handleIntersection, options);

                // 4. Start observing a target element
                const targetElement = document.querySelector('.profile-pic');
                if (targetElement) {
                  observer.observe(targetElement);
                }
            });
        </script>

        <script>
            function getRandomIntInclusive(min, max) {
                min = Math.ceil(min);   // Ensure min is an integer
                max = Math.floor(max);  // Ensure max is an integer
                // The formula ensures an even distribution across the range, including both min and max
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            

            function handleMouseMove(event) {
                const x = event.clientX;
                const y = event.clientY;

                const newDiv = document.createElement("div");
                newDiv.classList.add("square"); 
                newDiv.style.left = `${x-getRandomIntInclusive(-56, 56)}px`;
                newDiv.style.top = `${y-getRandomIntInclusive(-56, 56)}px`;

                document.body.appendChild(newDiv); // -2) take a break to think about how you feel; might go against chill vibe -1) tryout random placements near mouse; learn how random num works 0) on click, make shapes white 1) limit how often it runs, so we can see the individual shapes 2) add a scale on click 3) delete shapes after a while 4) Save this and then explore grid approach like Browser Company
            }

            document.addEventListener('mousemove', handleMouseMove);
        </script>
    </body>

    <!-- https://share.google/aimode/5FDOFPvtJi2angWTH // how to create trailing effect -->
    <!-- https://share.google/aimode/v73PtepUm6GNajldm // something that follows mouse -->
    <!-- Maybe just start with painting a square anywhere on the screen first; small steps -->

    <!-- https://stackoverflow.com/questions/60289558/how-to-animate-css-element-only-when-it-appears-on-a-window // Take a break to fix animation so that it only starts when elements are visible in viewport -->

    <!-- https://share.google/aimode/g73DJudU6Ifgn2QI6 // Determine if tab is being looked at, then trigger the animation only once-->

    <!-- https://share.google/aimode/Ryv3ChhoXdPk8F0Y0 // Chrome loads pages too fast, so animation starts too soon; UPDATE: Tried the DOMContentLoaded approach, didn't work, so try intersectionObserver API -->

    <!-- https://css-tricks.com/making-animations-wait/ // Making animations wait; try the IntersectionObserverAPI first-->

    <!--
    <script>
        document.addEventListener('mousemove', (e) => {
            const square = document.createElement('div');
            square.classList.add('test-square');

            square.style.left = '${e.clientX - 8}px';
            square.style.right = '$(e.clientY - 8}px';
            console.log('the left coord: ' + square.style.left);

            document.body.appendChild(square);
        }); 
    </script> 
    -->
</html>

